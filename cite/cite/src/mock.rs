//! Mock source parsing for procedural macros
//! 
//! This module handles parsing of mock source expressions in the #[cite] attribute.
use syn::Expr;
use cite_core::mock::MockSource;

/// Try to construct a MockSource from the citation expression
/// 
/// This function handles parsing of MockSource constructor expressions generated
/// by the helper macros and creates the appropriate MockSource during macro expansion.
pub fn try_construct_mock_source_from_expr(expr: &Expr) -> Option<MockSource> {
    // Parse MockSource::same() and MockSource::changed() expressions
    // These are generated by our helper macros same!() and changed!()
    if let Expr::Call(call_expr) = expr {
        if let Expr::Path(path_expr) = &*call_expr.func {
            let path_segments: Vec<_> = path_expr.path.segments.iter().collect();
            
            // Handle MockSource::same("content")
            if path_segments.len() == 2 
                && path_segments[0].ident == "MockSource" 
                && path_segments[1].ident == "same"
                && call_expr.args.len() == 1 {
                if let Expr::Lit(lit_expr) = &call_expr.args[0] {
                    if let syn::Lit::Str(str_lit) = &lit_expr.lit {
                        return Some(MockSource::same(str_lit.value()));
                    }
                }
            }
            
            // Handle MockSource::changed("old", "new")
            if path_segments.len() == 2 
                && path_segments[0].ident == "MockSource" 
                && path_segments[1].ident == "changed"
                && call_expr.args.len() == 2 {
                if let (Expr::Lit(lit1), Expr::Lit(lit2)) = (&call_expr.args[0], &call_expr.args[1]) {
                    if let (syn::Lit::Str(str1), syn::Lit::Str(str2)) = (&lit1.lit, &lit2.lit) {
                        return Some(MockSource::changed(str1.value(), str2.value()));
                    }
                }
            }
            
            // Handle fully qualified paths like ::cite_core::mock::MockSource::same
            if path_segments.len() > 2 {
                let last_two: Vec<_> = path_segments.iter().rev().take(2).collect();
                if last_two.len() == 2 
                    && last_two[1].ident == "MockSource" 
                    && last_two[0].ident == "same"
                    && call_expr.args.len() == 1 {
                    if let Expr::Lit(lit_expr) = &call_expr.args[0] {
                        if let syn::Lit::Str(str_lit) = &lit_expr.lit {
                            return Some(MockSource::same(str_lit.value()));
                        }
                    }
                }
                
                if last_two.len() == 2 
                    && last_two[1].ident == "MockSource" 
                    && last_two[0].ident == "changed"
                    && call_expr.args.len() == 2 {
                    if let (Expr::Lit(lit1), Expr::Lit(lit2)) = (&call_expr.args[0], &call_expr.args[1]) {
                        if let (syn::Lit::Str(str1), syn::Lit::Str(str2)) = (&lit1.lit, &lit2.lit) {
                            return Some(MockSource::changed(str1.value(), str2.value()));
                        }
                    }
                }
            }
        }
    }
    
    None
}